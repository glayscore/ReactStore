{"ast":null,"code":"/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\nimport { BufferAttribute, BufferGeometry, LineSegments, Mesh, Points } from \"../../../../../build/three.module.js\";\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\n\nconst MeshReceiver = function (materialHandler) {\n  this.logging = {\n    enabled: false,\n    debug: false\n  };\n  this.callbacks = {\n    onProgress: null,\n    onMeshAlter: null\n  };\n  this.materialHandler = materialHandler;\n};\n\nMeshReceiver.prototype = {\n  constructor: MeshReceiver,\n\n  /**\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  setLogging: function (enabled, debug) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n  },\n\n  /**\n   *\n   * @param {Function} onProgress\n   * @param {Function} onMeshAlter\n   * @private\n   */\n  _setCallbacks: function (onProgress, onMeshAlter) {\n    if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\n      this.callbacks.onProgress = onProgress;\n    }\n\n    if (onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function) {\n      this.callbacks.onMeshAlter = onMeshAlter;\n    }\n  },\n\n  /**\n   * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n   *\n   * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n   * @returns {Mesh[]} mesh Array of {@link Mesh}\n   */\n  buildMeshes: function (meshPayload) {\n    let meshName = meshPayload.params.meshName;\n    let buffers = meshPayload.buffers;\n    let bufferGeometry = new BufferGeometry();\n\n    if (buffers.vertices !== undefined && buffers.vertices !== null) {\n      bufferGeometry.setAttribute('position', new BufferAttribute(new Float32Array(buffers.vertices), 3));\n    }\n\n    if (buffers.indices !== undefined && buffers.indices !== null) {\n      bufferGeometry.setIndex(new BufferAttribute(new Uint32Array(buffers.indices), 1));\n    }\n\n    if (buffers.colors !== undefined && buffers.colors !== null) {\n      bufferGeometry.setAttribute('color', new BufferAttribute(new Float32Array(buffers.colors), 3));\n    }\n\n    if (buffers.normals !== undefined && buffers.normals !== null) {\n      bufferGeometry.setAttribute('normal', new BufferAttribute(new Float32Array(buffers.normals), 3));\n    } else {\n      bufferGeometry.computeVertexNormals();\n    }\n\n    if (buffers.uvs !== undefined && buffers.uvs !== null) {\n      bufferGeometry.setAttribute('uv', new BufferAttribute(new Float32Array(buffers.uvs), 2));\n    }\n\n    if (buffers.skinIndex !== undefined && buffers.skinIndex !== null) {\n      bufferGeometry.setAttribute('skinIndex', new BufferAttribute(new Uint16Array(buffers.skinIndex), 4));\n    }\n\n    if (buffers.skinWeight !== undefined && buffers.skinWeight !== null) {\n      bufferGeometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(buffers.skinWeight), 4));\n    }\n\n    let material, materialName, key;\n    let materialNames = meshPayload.materials.materialNames;\n    let createMultiMaterial = meshPayload.materials.multiMaterial;\n    let multiMaterials = [];\n\n    for (key in materialNames) {\n      materialName = materialNames[key];\n      material = this.materialHandler.getMaterial(materialName);\n      if (createMultiMaterial) multiMaterials.push(material);\n    }\n\n    if (createMultiMaterial) {\n      material = multiMaterials;\n      let materialGroups = meshPayload.materials.materialGroups;\n      let materialGroup;\n\n      for (key in materialGroups) {\n        materialGroup = materialGroups[key];\n        bufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);\n      }\n    }\n\n    let meshes = [];\n    let mesh;\n    let callbackOnMeshAlterResult;\n    let useOrgMesh = true;\n    let geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n    if (this.callbacks.onMeshAlter) {\n      callbackOnMeshAlterResult = this.callbacks.onMeshAlter({\n        detail: {\n          meshName: meshName,\n          bufferGeometry: bufferGeometry,\n          material: material,\n          geometryType: geometryType\n        }\n      });\n    } // here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\n\n    if (callbackOnMeshAlterResult) {\n      if (callbackOnMeshAlterResult.isDisregardMesh()) {\n        useOrgMesh = false;\n      } else if (callbackOnMeshAlterResult.providesAlteredMeshes()) {\n        for (let i in callbackOnMeshAlterResult.meshes) {\n          meshes.push(callbackOnMeshAlterResult.meshes[i]);\n        }\n\n        useOrgMesh = false;\n      }\n    }\n\n    if (useOrgMesh) {\n      if (meshPayload.computeBoundingSphere) bufferGeometry.computeBoundingSphere();\n\n      if (geometryType === 0) {\n        mesh = new Mesh(bufferGeometry, material);\n      } else if (geometryType === 1) {\n        mesh = new LineSegments(bufferGeometry, material);\n      } else {\n        mesh = new Points(bufferGeometry, material);\n      }\n\n      mesh.name = meshName;\n      meshes.push(mesh);\n    }\n\n    let progressMessage = meshPayload.params.meshName;\n\n    if (meshes.length > 0) {\n      let meshNames = [];\n\n      for (let i in meshes) {\n        mesh = meshes[i];\n        meshNames[i] = mesh.name;\n      }\n\n      progressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n      progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n    } else {\n      progressMessage += ': Not adding mesh: ' + meshName;\n      progressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n    }\n\n    if (this.callbacks.onProgress) {\n      this.callbacks.onProgress('progress', progressMessage, meshPayload.progress.numericalValue);\n    }\n\n    return meshes;\n  }\n};\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\n\nconst LoadedMeshUserOverride = function (disregardMesh, alteredMesh) {\n  this.disregardMesh = disregardMesh === true;\n  this.alteredMesh = alteredMesh === true;\n  this.meshes = [];\n};\n\nLoadedMeshUserOverride.prototype = {\n  constructor: LoadedMeshUserOverride,\n\n  /**\n   * Add a mesh created within callback.\n   *\n   * @param {Mesh} mesh\n   */\n  addMesh: function (mesh) {\n    this.meshes.push(mesh);\n    this.alteredMesh = true;\n  },\n\n  /**\n   * Answers if mesh shall be disregarded completely.\n   *\n   * @returns {boolean}\n   */\n  isDisregardMesh: function () {\n    return this.disregardMesh;\n  },\n\n  /**\n   * Answers if new mesh(es) were created.\n   *\n   * @returns {boolean}\n   */\n  providesAlteredMeshes: function () {\n    return this.alteredMesh;\n  }\n};\nexport { MeshReceiver, LoadedMeshUserOverride };","map":{"version":3,"sources":["C:/Users/Admin/Desktop/Docs/Web/cg/cg_panner/node_modules/three/examples/jsm/loaders/obj2/shared/MeshReceiver.js"],"names":["BufferAttribute","BufferGeometry","LineSegments","Mesh","Points","MeshReceiver","materialHandler","logging","enabled","debug","callbacks","onProgress","onMeshAlter","prototype","constructor","setLogging","_setCallbacks","undefined","Function","buildMeshes","meshPayload","meshName","params","buffers","bufferGeometry","vertices","setAttribute","Float32Array","indices","setIndex","Uint32Array","colors","normals","computeVertexNormals","uvs","skinIndex","Uint16Array","skinWeight","material","materialName","key","materialNames","materials","createMultiMaterial","multiMaterial","multiMaterials","getMaterial","push","materialGroups","materialGroup","addGroup","start","count","index","meshes","mesh","callbackOnMeshAlterResult","useOrgMesh","geometryType","detail","isDisregardMesh","providesAlteredMeshes","i","computeBoundingSphere","name","progressMessage","length","meshNames","progress","numericalValue","toFixed","LoadedMeshUserOverride","disregardMesh","alteredMesh","addMesh"],"mappings":"AAAA;;;;AAKA,SACCA,eADD,EAECC,cAFD,EAGCC,YAHD,EAICC,IAJD,EAKCC,MALD,QAMO,sCANP;AASA;;;;;;AAKA,MAAMC,YAAY,GAAG,UAAWC,eAAX,EAA6B;AAEjD,OAAKC,OAAL,GAAe;AACdC,IAAAA,OAAO,EAAE,KADK;AAEdC,IAAAA,KAAK,EAAE;AAFO,GAAf;AAKA,OAAKC,SAAL,GAAiB;AAChBC,IAAAA,UAAU,EAAE,IADI;AAEhBC,IAAAA,WAAW,EAAE;AAFG,GAAjB;AAIA,OAAKN,eAAL,GAAuBA,eAAvB;AAEA,CAbD;;AAeAD,YAAY,CAACQ,SAAb,GAAyB;AAExBC,EAAAA,WAAW,EAAET,YAFW;;AAIxB;;;;;;AAMAU,EAAAA,UAAU,EAAE,UAAWP,OAAX,EAAoBC,KAApB,EAA4B;AAEvC,SAAKF,OAAL,CAAaC,OAAb,GAAuBA,OAAO,KAAK,IAAnC;AACA,SAAKD,OAAL,CAAaE,KAAb,GAAqBA,KAAK,KAAK,IAA/B;AAEA,GAfuB;;AAiBxB;;;;;;AAMAO,EAAAA,aAAa,EAAE,UAAWL,UAAX,EAAuBC,WAAvB,EAAqC;AAEnD,QAAKD,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAKM,SAAtC,IAAmDN,UAAU,YAAYO,QAA9E,EAAyF;AAExF,WAAKR,SAAL,CAAeC,UAAf,GAA4BA,UAA5B;AAEA;;AAED,QAAKC,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAKK,SAAxC,IAAqDL,WAAW,YAAYM,QAAjF,EAA4F;AAE3F,WAAKR,SAAL,CAAeE,WAAf,GAA6BA,WAA7B;AAEA;AAED,GArCuB;;AAuCxB;;;;;;AAMAO,EAAAA,WAAW,EAAE,UAAWC,WAAX,EAAyB;AAErC,QAAIC,QAAQ,GAAGD,WAAW,CAACE,MAAZ,CAAmBD,QAAlC;AACA,QAAIE,OAAO,GAAGH,WAAW,CAACG,OAA1B;AAEA,QAAIC,cAAc,GAAG,IAAIvB,cAAJ,EAArB;;AACA,QAAKsB,OAAO,CAACE,QAAR,KAAqBR,SAArB,IAAkCM,OAAO,CAACE,QAAR,KAAqB,IAA5D,EAAmE;AAElED,MAAAA,cAAc,CAACE,YAAf,CAA6B,UAA7B,EAAyC,IAAI1B,eAAJ,CAAqB,IAAI2B,YAAJ,CAAkBJ,OAAO,CAACE,QAA1B,CAArB,EAA2D,CAA3D,CAAzC;AAEA;;AAED,QAAKF,OAAO,CAACK,OAAR,KAAoBX,SAApB,IAAiCM,OAAO,CAACK,OAAR,KAAoB,IAA1D,EAAiE;AAEhEJ,MAAAA,cAAc,CAACK,QAAf,CAAyB,IAAI7B,eAAJ,CAAqB,IAAI8B,WAAJ,CAAiBP,OAAO,CAACK,OAAzB,CAArB,EAAyD,CAAzD,CAAzB;AAEA;;AAED,QAAKL,OAAO,CAACQ,MAAR,KAAmBd,SAAnB,IAAgCM,OAAO,CAACQ,MAAR,KAAmB,IAAxD,EAA+D;AAE9DP,MAAAA,cAAc,CAACE,YAAf,CAA6B,OAA7B,EAAsC,IAAI1B,eAAJ,CAAqB,IAAI2B,YAAJ,CAAkBJ,OAAO,CAACQ,MAA1B,CAArB,EAAyD,CAAzD,CAAtC;AAEA;;AAED,QAAKR,OAAO,CAACS,OAAR,KAAoBf,SAApB,IAAiCM,OAAO,CAACS,OAAR,KAAoB,IAA1D,EAAiE;AAEhER,MAAAA,cAAc,CAACE,YAAf,CAA6B,QAA7B,EAAuC,IAAI1B,eAAJ,CAAqB,IAAI2B,YAAJ,CAAkBJ,OAAO,CAACS,OAA1B,CAArB,EAA0D,CAA1D,CAAvC;AAEA,KAJD,MAIO;AAENR,MAAAA,cAAc,CAACS,oBAAf;AAEA;;AAED,QAAKV,OAAO,CAACW,GAAR,KAAgBjB,SAAhB,IAA6BM,OAAO,CAACW,GAAR,KAAgB,IAAlD,EAAyD;AAExDV,MAAAA,cAAc,CAACE,YAAf,CAA6B,IAA7B,EAAmC,IAAI1B,eAAJ,CAAqB,IAAI2B,YAAJ,CAAkBJ,OAAO,CAACW,GAA1B,CAArB,EAAsD,CAAtD,CAAnC;AAEA;;AAED,QAAKX,OAAO,CAACY,SAAR,KAAsBlB,SAAtB,IAAmCM,OAAO,CAACY,SAAR,KAAsB,IAA9D,EAAqE;AAEpEX,MAAAA,cAAc,CAACE,YAAf,CAA6B,WAA7B,EAA0C,IAAI1B,eAAJ,CAAqB,IAAIoC,WAAJ,CAAiBb,OAAO,CAACY,SAAzB,CAArB,EAA2D,CAA3D,CAA1C;AAEA;;AAED,QAAKZ,OAAO,CAACc,UAAR,KAAuBpB,SAAvB,IAAoCM,OAAO,CAACc,UAAR,KAAuB,IAAhE,EAAuE;AAEtEb,MAAAA,cAAc,CAACE,YAAf,CAA6B,YAA7B,EAA2C,IAAI1B,eAAJ,CAAqB,IAAI2B,YAAJ,CAAkBJ,OAAO,CAACc,UAA1B,CAArB,EAA6D,CAA7D,CAA3C;AAEA;;AAED,QAAIC,QAAJ,EAAcC,YAAd,EAA4BC,GAA5B;AACA,QAAIC,aAAa,GAAGrB,WAAW,CAACsB,SAAZ,CAAsBD,aAA1C;AACA,QAAIE,mBAAmB,GAAGvB,WAAW,CAACsB,SAAZ,CAAsBE,aAAhD;AACA,QAAIC,cAAc,GAAG,EAArB;;AAEA,SAAML,GAAN,IAAaC,aAAb,EAA6B;AAE5BF,MAAAA,YAAY,GAAGE,aAAa,CAAED,GAAF,CAA5B;AACAF,MAAAA,QAAQ,GAAG,KAAKhC,eAAL,CAAqBwC,WAArB,CAAkCP,YAAlC,CAAX;AACA,UAAKI,mBAAL,EAA2BE,cAAc,CAACE,IAAf,CAAqBT,QAArB;AAE3B;;AAED,QAAKK,mBAAL,EAA2B;AAE1BL,MAAAA,QAAQ,GAAGO,cAAX;AACA,UAAIG,cAAc,GAAG5B,WAAW,CAACsB,SAAZ,CAAsBM,cAA3C;AACA,UAAIC,aAAJ;;AACA,WAAMT,GAAN,IAAaQ,cAAb,EAA8B;AAE7BC,QAAAA,aAAa,GAAGD,cAAc,CAAER,GAAF,CAA9B;AACAhB,QAAAA,cAAc,CAAC0B,QAAf,CAAyBD,aAAa,CAACE,KAAvC,EAA8CF,aAAa,CAACG,KAA5D,EAAmEH,aAAa,CAACI,KAAjF;AAEA;AAED;;AAED,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,IAAJ;AACA,QAAIC,yBAAJ;AACA,QAAIC,UAAU,GAAG,IAAjB;AACA,QAAIC,YAAY,GAAGtC,WAAW,CAACsC,YAAZ,KAA6B,IAA7B,GAAoC,CAApC,GAAwCtC,WAAW,CAACsC,YAAvE;;AAEA,QAAK,KAAKhD,SAAL,CAAeE,WAApB,EAAkC;AAEjC4C,MAAAA,yBAAyB,GAAG,KAAK9C,SAAL,CAAeE,WAAf,CAC3B;AACC+C,QAAAA,MAAM,EAAE;AACPtC,UAAAA,QAAQ,EAAEA,QADH;AAEPG,UAAAA,cAAc,EAAEA,cAFT;AAGPc,UAAAA,QAAQ,EAAEA,QAHH;AAIPoB,UAAAA,YAAY,EAAEA;AAJP;AADT,OAD2B,CAA5B;AAWA,KAlGoC,CAoGrC;;;AACA,QAAKF,yBAAL,EAAiC;AAEhC,UAAKA,yBAAyB,CAACI,eAA1B,EAAL,EAAmD;AAElDH,QAAAA,UAAU,GAAG,KAAb;AAEA,OAJD,MAIO,IAAKD,yBAAyB,CAACK,qBAA1B,EAAL,EAAyD;AAE/D,aAAM,IAAIC,CAAV,IAAeN,yBAAyB,CAACF,MAAzC,EAAkD;AAEjDA,UAAAA,MAAM,CAACP,IAAP,CAAaS,yBAAyB,CAACF,MAA1B,CAAkCQ,CAAlC,CAAb;AAEA;;AAEDL,QAAAA,UAAU,GAAG,KAAb;AAEA;AAED;;AAED,QAAKA,UAAL,EAAkB;AAEjB,UAAKrC,WAAW,CAAC2C,qBAAjB,EAAyCvC,cAAc,CAACuC,qBAAf;;AACzC,UAAKL,YAAY,KAAK,CAAtB,EAA0B;AAEzBH,QAAAA,IAAI,GAAG,IAAIpD,IAAJ,CAAUqB,cAAV,EAA0Bc,QAA1B,CAAP;AAEA,OAJD,MAIO,IAAKoB,YAAY,KAAK,CAAtB,EAA0B;AAEhCH,QAAAA,IAAI,GAAG,IAAIrD,YAAJ,CAAkBsB,cAAlB,EAAkCc,QAAlC,CAAP;AAEA,OAJM,MAIA;AAENiB,QAAAA,IAAI,GAAG,IAAInD,MAAJ,CAAYoB,cAAZ,EAA4Bc,QAA5B,CAAP;AAEA;;AAEDiB,MAAAA,IAAI,CAACS,IAAL,GAAY3C,QAAZ;AACAiC,MAAAA,MAAM,CAACP,IAAP,CAAaQ,IAAb;AAEA;;AAED,QAAIU,eAAe,GAAG7C,WAAW,CAACE,MAAZ,CAAmBD,QAAzC;;AACA,QAAKiC,MAAM,CAACY,MAAP,GAAgB,CAArB,EAAyB;AAExB,UAAIC,SAAS,GAAG,EAAhB;;AACA,WAAM,IAAIL,CAAV,IAAeR,MAAf,EAAwB;AAEvBC,QAAAA,IAAI,GAAGD,MAAM,CAAEQ,CAAF,CAAb;AACAK,QAAAA,SAAS,CAAEL,CAAF,CAAT,GAAiBP,IAAI,CAACS,IAAtB;AAEA;;AAEDC,MAAAA,eAAe,IAAI,wBAAwBE,SAAS,CAACD,MAAlC,GAA2C,IAA3C,GAAkDC,SAAlD,GAA8D,qBAA9D,GAAsF9C,QAAzG;AACA4C,MAAAA,eAAe,IAAI,OAAO,CAAE7C,WAAW,CAACgD,QAAZ,CAAqBC,cAArB,GAAsC,GAAxC,EAA8CC,OAA9C,CAAuD,CAAvD,CAAP,GAAoE,IAAvF;AAEA,KAbD,MAaO;AAENL,MAAAA,eAAe,IAAI,wBAAwB5C,QAA3C;AACA4C,MAAAA,eAAe,IAAI,OAAO,CAAE7C,WAAW,CAACgD,QAAZ,CAAqBC,cAArB,GAAsC,GAAxC,EAA8CC,OAA9C,CAAuD,CAAvD,CAAP,GAAoE,IAAvF;AAEA;;AAED,QAAK,KAAK5D,SAAL,CAAeC,UAApB,EAAiC;AAEhC,WAAKD,SAAL,CAAeC,UAAf,CAA2B,UAA3B,EAAuCsD,eAAvC,EAAwD7C,WAAW,CAACgD,QAAZ,CAAqBC,cAA7E;AAEA;;AAED,WAAOf,MAAP;AAEA;AAzNuB,CAAzB;AA6NA;;;;;;;;AAOA,MAAMiB,sBAAsB,GAAG,UAAWC,aAAX,EAA0BC,WAA1B,EAAwC;AAEtE,OAAKD,aAAL,GAAqBA,aAAa,KAAK,IAAvC;AACA,OAAKC,WAAL,GAAmBA,WAAW,KAAK,IAAnC;AACA,OAAKnB,MAAL,GAAc,EAAd;AAEA,CAND;;AASAiB,sBAAsB,CAAC1D,SAAvB,GAAmC;AAElCC,EAAAA,WAAW,EAAEyD,sBAFqB;;AAIlC;;;;;AAKAG,EAAAA,OAAO,EAAE,UAAWnB,IAAX,EAAkB;AAE1B,SAAKD,MAAL,CAAYP,IAAZ,CAAkBQ,IAAlB;AACA,SAAKkB,WAAL,GAAmB,IAAnB;AAEA,GAdiC;;AAgBlC;;;;;AAKAb,EAAAA,eAAe,EAAE,YAAY;AAE5B,WAAO,KAAKY,aAAZ;AAEA,GAzBiC;;AA2BlC;;;;;AAKAX,EAAAA,qBAAqB,EAAE,YAAY;AAElC,WAAO,KAAKY,WAAZ;AAEA;AApCiC,CAAnC;AAuCA,SACCpE,YADD,EAECkE,sBAFD","sourcesContent":["/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\nimport {\n\tBufferAttribute,\n\tBufferGeometry,\n\tLineSegments,\n\tMesh,\n\tPoints\n} from \"../../../../../build/three.module.js\";\n\n\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\nconst MeshReceiver = function ( materialHandler ) {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonProgress: null,\n\t\tonMeshAlter: null\n\t};\n\tthis.materialHandler = materialHandler;\n\n};\n\nMeshReceiver.prototype = {\n\n\tconstructor: MeshReceiver,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t/**\n\t *\n\t * @param {Function} onProgress\n\t * @param {Function} onMeshAlter\n\t * @private\n\t */\n\t_setCallbacks: function ( onProgress, onMeshAlter ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\n\t\tif ( onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function ) {\n\n\t\t\tthis.callbacks.onMeshAlter = onMeshAlter;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n\t *\n\t * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n\t * @returns {Mesh[]} mesh Array of {@link Mesh}\n\t */\n\tbuildMeshes: function ( meshPayload ) {\n\n\t\tlet meshName = meshPayload.params.meshName;\n\t\tlet buffers = meshPayload.buffers;\n\n\t\tlet bufferGeometry = new BufferGeometry();\n\t\tif ( buffers.vertices !== undefined && buffers.vertices !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( buffers.vertices ), 3 ) );\n\n\t\t}\n\n\t\tif ( buffers.indices !== undefined && buffers.indices !== null ) {\n\n\t\t\tbufferGeometry.setIndex( new BufferAttribute( new Uint32Array( buffers.indices ), 1 ) );\n\n\t\t}\n\n\t\tif ( buffers.colors !== undefined && buffers.colors !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'color', new BufferAttribute( new Float32Array( buffers.colors ), 3 ) );\n\n\t\t}\n\n\t\tif ( buffers.normals !== undefined && buffers.normals !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( buffers.normals ), 3 ) );\n\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\n\t\t}\n\n\t\tif ( buffers.uvs !== undefined && buffers.uvs !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( buffers.uvs ), 2 ) );\n\n\t\t}\n\n\t\tif ( buffers.skinIndex !== undefined && buffers.skinIndex !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinIndex', new BufferAttribute( new Uint16Array( buffers.skinIndex ), 4 ) );\n\n\t\t}\n\n\t\tif ( buffers.skinWeight !== undefined && buffers.skinWeight !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinWeight', new BufferAttribute( new Float32Array( buffers.skinWeight ), 4 ) );\n\n\t\t}\n\n\t\tlet material, materialName, key;\n\t\tlet materialNames = meshPayload.materials.materialNames;\n\t\tlet createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tlet multiMaterials = [];\n\n\t\tfor ( key in materialNames ) {\n\n\t\t\tmaterialName = materialNames[ key ];\n\t\t\tmaterial = this.materialHandler.getMaterial( materialName );\n\t\t\tif ( createMultiMaterial ) multiMaterials.push( material );\n\n\t\t}\n\n\t\tif ( createMultiMaterial ) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tlet materialGroups = meshPayload.materials.materialGroups;\n\t\t\tlet materialGroup;\n\t\t\tfor ( key in materialGroups ) {\n\n\t\t\t\tmaterialGroup = materialGroups[ key ];\n\t\t\t\tbufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet meshes = [];\n\t\tlet mesh;\n\t\tlet callbackOnMeshAlterResult;\n\t\tlet useOrgMesh = true;\n\t\tlet geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n\t\tif ( this.callbacks.onMeshAlter ) {\n\n\t\t\tcallbackOnMeshAlterResult = this.callbacks.onMeshAlter(\n\t\t\t\t{\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\t// here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\t\tif ( callbackOnMeshAlterResult ) {\n\n\t\t\tif ( callbackOnMeshAlterResult.isDisregardMesh() ) {\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\n\n\t\t\t\tfor ( let i in callbackOnMeshAlterResult.meshes ) {\n\n\t\t\t\t\tmeshes.push( callbackOnMeshAlterResult.meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( useOrgMesh ) {\n\n\t\t\tif ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();\n\t\t\tif ( geometryType === 0 ) {\n\n\t\t\t\tmesh = new Mesh( bufferGeometry, material );\n\n\t\t\t} else if ( geometryType === 1 ) {\n\n\t\t\t\tmesh = new LineSegments( bufferGeometry, material );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = new Points( bufferGeometry, material );\n\n\t\t\t}\n\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push( mesh );\n\n\t\t}\n\n\t\tlet progressMessage = meshPayload.params.meshName;\n\t\tif ( meshes.length > 0 ) {\n\n\t\t\tlet meshNames = [];\n\t\t\tfor ( let i in meshes ) {\n\n\t\t\t\tmesh = meshes[ i ];\n\t\t\t\tmeshNames[ i ] = mesh.name;\n\n\t\t\t}\n\n\t\t\tprogressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t} else {\n\n\t\t\tprogressMessage += ': Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t}\n\n\t\tif ( this.callbacks.onProgress ) {\n\n\t\t\tthis.callbacks.onProgress( 'progress', progressMessage, meshPayload.progress.numericalValue );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n};\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nconst LoadedMeshUserOverride = function ( disregardMesh, alteredMesh ) {\n\n\tthis.disregardMesh = disregardMesh === true;\n\tthis.alteredMesh = alteredMesh === true;\n\tthis.meshes = [];\n\n};\n\n\nLoadedMeshUserOverride.prototype = {\n\n\tconstructor: LoadedMeshUserOverride,\n\n\t/**\n\t * Add a mesh created within callback.\n\t *\n\t * @param {Mesh} mesh\n\t */\n\taddMesh: function ( mesh ) {\n\n\t\tthis.meshes.push( mesh );\n\t\tthis.alteredMesh = true;\n\n\t},\n\n\t/**\n\t * Answers if mesh shall be disregarded completely.\n\t *\n\t * @returns {boolean}\n\t */\n\tisDisregardMesh: function () {\n\n\t\treturn this.disregardMesh;\n\n\t},\n\n\t/**\n\t * Answers if new mesh(es) were created.\n\t *\n\t * @returns {boolean}\n\t */\n\tprovidesAlteredMeshes: function () {\n\n\t\treturn this.alteredMesh;\n\n\t}\n};\n\nexport {\n\tMeshReceiver,\n\tLoadedMeshUserOverride\n};\n"]},"metadata":{},"sourceType":"module"}