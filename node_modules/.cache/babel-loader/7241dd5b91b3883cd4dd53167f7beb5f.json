{"ast":null,"code":"/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n/**\n * Parse OBJ data either from ArrayBuffer or string\n */\nconst OBJLoader2Parser = function () {\n  this.logging = {\n    enabled: false,\n    debug: false\n  };\n  let scope = this;\n  this.callbacks = {\n    onProgress: function (text) {\n      scope._onProgress(text);\n    },\n    onAssetAvailable: function (payload) {\n      scope._onAssetAvailable(payload);\n    },\n    onError: function (errorMessage) {\n      scope._onError(errorMessage);\n    },\n    onLoad: function (object3d, message) {\n      scope._onLoad(object3d, message);\n    }\n  };\n  this.contentRef = null;\n  this.legacyMode = false;\n  this.materials = {};\n  this.materialPerSmoothingGroup = false;\n  this.useOAsMesh = false;\n  this.useIndices = false;\n  this.disregardNormals = false;\n  this.vertices = [];\n  this.colors = [];\n  this.normals = [];\n  this.uvs = [];\n  this.rawMesh = {\n    objectName: '',\n    groupName: '',\n    activeMtlName: '',\n    mtllibName: '',\n    // reset with new mesh\n    faceType: -1,\n    subGroups: [],\n    subGroupInUse: null,\n    smoothingGroup: {\n      splitMaterials: false,\n      normalized: -1,\n      real: -1\n    },\n    counts: {\n      doubleIndicesCount: 0,\n      faceCount: 0,\n      mtlCount: 0,\n      smoothingGroupCount: 0\n    }\n  };\n  this.inputObjectCount = 1;\n  this.outputObjectCount = 1;\n  this.globalCounts = {\n    vertices: 0,\n    faces: 0,\n    doubleIndicesCount: 0,\n    lineByte: 0,\n    currentByte: 0,\n    totalBytes: 0\n  };\n};\n\nOBJLoader2Parser.prototype = {\n  constructor: OBJLoader2Parser,\n  _resetRawMesh: function () {\n    // faces are stored according combined index of group, material and smoothingGroup (0 or not)\n    this.rawMesh.subGroups = [];\n    this.rawMesh.subGroupInUse = null;\n    this.rawMesh.smoothingGroup.normalized = -1;\n    this.rawMesh.smoothingGroup.real = -1; // this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\n    this._pushSmoothingGroup(1);\n\n    this.rawMesh.counts.doubleIndicesCount = 0;\n    this.rawMesh.counts.faceCount = 0;\n    this.rawMesh.counts.mtlCount = 0;\n    this.rawMesh.counts.smoothingGroupCount = 0;\n  },\n\n  /**\n   * Tells whether a material shall be created per smoothing group.\n   *\n   * @param {boolean} materialPerSmoothingGroup=false\n   * @return {OBJLoader2Parser}\n   */\n  setMaterialPerSmoothingGroup: function (materialPerSmoothingGroup) {\n    this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n    return this;\n  },\n\n  /**\n   * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n   *\n   * @param {boolean} useOAsMesh=false\n   * @return {OBJLoader2Parser}\n   */\n  setUseOAsMesh: function (useOAsMesh) {\n    this.useOAsMesh = useOAsMesh === true;\n    return this;\n  },\n\n  /**\n   * Instructs loaders to create indexed {@link BufferGeometry}.\n   *\n   * @param {boolean} useIndices=false\n   * @return {OBJLoader2Parser}\n   */\n  setUseIndices: function (useIndices) {\n    this.useIndices = useIndices === true;\n    return this;\n  },\n\n  /**\n   * Tells whether normals should be completely disregarded and regenerated.\n   *\n   * @param {boolean} disregardNormals=false\n   * @return {OBJLoader2Parser}\n   */\n  setDisregardNormals: function (disregardNormals) {\n    this.disregardNormals = disregardNormals === true;\n    return this;\n  },\n\n  /**\n   * Clears materials object and sets the new ones.\n   *\n   * @param {Object} materials Object with named materials\n   */\n  setMaterials: function (materials) {\n    this.materials = Object.assign({}, materials);\n  },\n\n  /**\n   * Register a function that is called once an asset (mesh/material) becomes available.\n   *\n   * @param onAssetAvailable\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnAssetAvailable: function (onAssetAvailable) {\n    if (onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function) {\n      this.callbacks.onAssetAvailable = onAssetAvailable;\n    }\n\n    return this;\n  },\n\n  /**\n   * Register a function that is used to report overall processing progress.\n   *\n   * @param {Function} onProgress\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnProgress: function (onProgress) {\n    if (onProgress !== null && onProgress !== undefined && onProgress instanceof Function) {\n      this.callbacks.onProgress = onProgress;\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.\n   *\n   * @param {Function} onError\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnError: function (onError) {\n    if (onError !== null && onError !== undefined && onError instanceof Function) {\n      this.callbacks.onError = onError;\n    }\n\n    return this;\n  },\n\n  /**\n   * Register a function that is called when parsing was completed.\n   *\n   * @param {Function} onLoad\n   * @return {OBJLoader2Parser}\n   */\n  setCallbackOnLoad: function (onLoad) {\n    if (onLoad !== null && onLoad !== undefined && onLoad instanceof Function) {\n      this.callbacks.onLoad = onLoad;\n    }\n\n    return this;\n  },\n\n  /**\n   * Announce parse progress feedback which is logged to the console.\n   * @private\n   *\n   * @param {string} text Textual description of the event\n   */\n  _onProgress: function (text) {\n    let message = text ? text : '';\n\n    if (this.logging.enabled && this.logging.debug) {\n      console.log(message);\n    }\n  },\n\n  /**\n   * Announce error feedback which is logged as error message.\n   * @private\n   *\n   * @param {String} errorMessage The event containing the error\n   */\n  _onError: function (errorMessage) {\n    if (this.logging.enabled && this.logging.debug) {\n      console.error(errorMessage);\n    }\n  },\n  _onAssetAvailable: function (payload) {\n    let errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\n    this.callbacks.onError(errorMessage);\n    throw errorMessage;\n  },\n  _onLoad: function (object3d, message) {\n    console.log(\"You reached parser default onLoad callback: \" + message);\n  },\n\n  /**\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   *\n   * @return {OBJLoader2Parser}\n   */\n  setLogging: function (enabled, debug) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n    return this;\n  },\n  _configure: function () {\n    this._pushSmoothingGroup(1);\n\n    if (this.logging.enabled) {\n      let matKeys = Object.keys(this.materials);\n      let matNames = matKeys.length > 0 ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join('\\n\\t\\t- ') : '\\n\\tmaterialNames: None';\n      let printedConfig = 'OBJLoader.Parser configuration:' + matNames + '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup + '\\n\\tuseOAsMesh: ' + this.useOAsMesh + '\\n\\tuseIndices: ' + this.useIndices + '\\n\\tdisregardNormals: ' + this.disregardNormals;\n      printedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\n      printedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\n      printedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\n      console.info(printedConfig);\n    }\n  },\n\n  /**\n   * Parse the provided arraybuffer\n   *\n   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n   */\n  execute: function (arrayBuffer) {\n    if (this.logging.enabled) console.time('OBJLoader2Parser.execute');\n\n    this._configure();\n\n    let arrayBufferView = new Uint8Array(arrayBuffer);\n    this.contentRef = arrayBufferView;\n    let length = arrayBufferView.byteLength;\n    this.globalCounts.totalBytes = length;\n    let buffer = new Array(128);\n    let bufferPointer = 0;\n    let slashesCount = 0;\n    let word = '';\n    let currentByte = 0;\n\n    for (let code, currentByte = 0; currentByte < length; currentByte++) {\n      code = arrayBufferView[currentByte];\n\n      switch (code) {\n        // space\n        case 32:\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          word = '';\n          break;\n        // slash\n\n        case 47:\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          slashesCount++;\n          word = '';\n          break;\n        // LF\n\n        case 10:\n          this._processLine(buffer, bufferPointer, slashesCount, word, currentByte);\n\n          word = '';\n          bufferPointer = 0;\n          slashesCount = 0;\n          break;\n        // CR\n\n        case 13:\n          break;\n\n        default:\n          word += String.fromCharCode(code);\n          break;\n      }\n    }\n\n    this._processLine(buffer, bufferPointer, slashesCount, word, currentByte);\n\n    this._finalizeParsing();\n\n    if (this.logging.enabled) console.timeEnd('OBJLoader2Parser.execute');\n  },\n\n  /**\n   * Parse the provided text\n   *\n   * @param {string} text OBJ data as string\n   */\n  executeLegacy: function (text) {\n    if (this.logging.enabled) console.time('OBJLoader2Parser.executeLegacy');\n\n    this._configure();\n\n    this.legacyMode = true;\n    this.contentRef = text;\n    let length = text.length;\n    this.globalCounts.totalBytes = length;\n    let buffer = new Array(128);\n    let bufferPointer = 0;\n    let slashesCount = 0;\n    let word = '';\n    let currentByte = 0;\n\n    for (let char; currentByte < length; currentByte++) {\n      char = text[currentByte];\n\n      switch (char) {\n        case ' ':\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          word = '';\n          break;\n\n        case '/':\n          if (word.length > 0) buffer[bufferPointer++] = word;\n          slashesCount++;\n          word = '';\n          break;\n\n        case '\\n':\n          this._processLine(buffer, bufferPointer, slashesCount, word, currentByte);\n\n          word = '';\n          bufferPointer = 0;\n          slashesCount = 0;\n          break;\n\n        case '\\r':\n          break;\n\n        default:\n          word += char;\n      }\n    }\n\n    this._processLine(buffer, bufferPointer, word, slashesCount);\n\n    this._finalizeParsing();\n\n    if (this.logging.enabled) console.timeEnd('OBJLoader2Parser.executeLegacy');\n  },\n  _processLine: function (buffer, bufferPointer, slashesCount, word, currentByte) {\n    this.globalCounts.lineByte = this.globalCounts.currentByte;\n    this.globalCounts.currentByte = currentByte;\n    if (bufferPointer < 1) return;\n    if (word.length > 0) buffer[bufferPointer++] = word;\n\n    let reconstructString = function (content, legacyMode, start, stop) {\n      let line = '';\n\n      if (stop > start) {\n        let i;\n\n        if (legacyMode) {\n          for (i = start; i < stop; i++) line += content[i];\n        } else {\n          for (i = start; i < stop; i++) line += String.fromCharCode(content[i]);\n        }\n\n        line = line.trim();\n      }\n\n      return line;\n    };\n\n    let bufferLength, length, i, lineDesignation;\n    lineDesignation = buffer[0];\n\n    switch (lineDesignation) {\n      case 'v':\n        this.vertices.push(parseFloat(buffer[1]));\n        this.vertices.push(parseFloat(buffer[2]));\n        this.vertices.push(parseFloat(buffer[3]));\n\n        if (bufferPointer > 4) {\n          this.colors.push(parseFloat(buffer[4]));\n          this.colors.push(parseFloat(buffer[5]));\n          this.colors.push(parseFloat(buffer[6]));\n        }\n\n        break;\n\n      case 'vt':\n        this.uvs.push(parseFloat(buffer[1]));\n        this.uvs.push(parseFloat(buffer[2]));\n        break;\n\n      case 'vn':\n        this.normals.push(parseFloat(buffer[1]));\n        this.normals.push(parseFloat(buffer[2]));\n        this.normals.push(parseFloat(buffer[3]));\n        break;\n\n      case 'f':\n        bufferLength = bufferPointer - 1; // \"f vertex ...\"\n\n        if (slashesCount === 0) {\n          this._checkFaceType(0);\n\n          for (i = 2, length = bufferLength; i < length; i++) {\n            this._buildFace(buffer[1]);\n\n            this._buildFace(buffer[i]);\n\n            this._buildFace(buffer[i + 1]);\n          } // \"f vertex/uv ...\"\n\n        } else if (bufferLength === slashesCount * 2) {\n          this._checkFaceType(1);\n\n          for (i = 3, length = bufferLength - 2; i < length; i += 2) {\n            this._buildFace(buffer[1], buffer[2]);\n\n            this._buildFace(buffer[i], buffer[i + 1]);\n\n            this._buildFace(buffer[i + 2], buffer[i + 3]);\n          } // \"f vertex/uv/normal ...\"\n\n        } else if (bufferLength * 2 === slashesCount * 3) {\n          this._checkFaceType(2);\n\n          for (i = 4, length = bufferLength - 3; i < length; i += 3) {\n            this._buildFace(buffer[1], buffer[2], buffer[3]);\n\n            this._buildFace(buffer[i], buffer[i + 1], buffer[i + 2]);\n\n            this._buildFace(buffer[i + 3], buffer[i + 4], buffer[i + 5]);\n          } // \"f vertex//normal ...\"\n\n        } else {\n          this._checkFaceType(3);\n\n          for (i = 3, length = bufferLength - 2; i < length; i += 2) {\n            this._buildFace(buffer[1], undefined, buffer[2]);\n\n            this._buildFace(buffer[i], undefined, buffer[i + 1]);\n\n            this._buildFace(buffer[i + 2], undefined, buffer[i + 3]);\n          }\n        }\n\n        break;\n\n      case 'l':\n      case 'p':\n        bufferLength = bufferPointer - 1;\n\n        if (bufferLength === slashesCount * 2) {\n          this._checkFaceType(4);\n\n          for (i = 1, length = bufferLength + 1; i < length; i += 2) this._buildFace(buffer[i], buffer[i + 1]);\n        } else {\n          this._checkFaceType(lineDesignation === 'l' ? 5 : 6);\n\n          for (i = 1, length = bufferLength + 1; i < length; i++) this._buildFace(buffer[i]);\n        }\n\n        break;\n\n      case 's':\n        this._pushSmoothingGroup(buffer[1]);\n\n        break;\n\n      case 'g':\n        // 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n        this._processCompletedMesh();\n\n        this.rawMesh.groupName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n        break;\n\n      case 'o':\n        // 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n        if (this.useOAsMesh) this._processCompletedMesh();\n        this.rawMesh.objectName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n        break;\n\n      case 'mtllib':\n        this.rawMesh.mtllibName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n        break;\n\n      case 'usemtl':\n        let mtlName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n\n        if (mtlName !== '' && this.rawMesh.activeMtlName !== mtlName) {\n          this.rawMesh.activeMtlName = mtlName;\n          this.rawMesh.counts.mtlCount++;\n\n          this._checkSubGroup();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  },\n  _pushSmoothingGroup: function (smoothingGroup) {\n    let smoothingGroupInt = parseInt(smoothingGroup);\n\n    if (isNaN(smoothingGroupInt)) {\n      smoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n    }\n\n    let smoothCheck = this.rawMesh.smoothingGroup.normalized;\n    this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : smoothingGroupInt === 0 ? 0 : 1;\n    this.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n    if (smoothCheck !== smoothingGroupInt) {\n      this.rawMesh.counts.smoothingGroupCount++;\n\n      this._checkSubGroup();\n    }\n  },\n\n  /**\n   * Expanded faceTypes include all four face types, both line types and the point type\n   * faceType = 0: \"f vertex ...\"\n   * faceType = 1: \"f vertex/uv ...\"\n   * faceType = 2: \"f vertex/uv/normal ...\"\n   * faceType = 3: \"f vertex//normal ...\"\n   * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n   * faceType = 5: \"l vertex ...\"\n   * faceType = 6: \"p vertex ...\"\n   */\n  _checkFaceType: function (faceType) {\n    if (this.rawMesh.faceType !== faceType) {\n      this._processCompletedMesh();\n\n      this.rawMesh.faceType = faceType;\n\n      this._checkSubGroup();\n    }\n  },\n  _checkSubGroup: function () {\n    let index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n    this.rawMesh.subGroupInUse = this.rawMesh.subGroups[index];\n\n    if (this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null) {\n      this.rawMesh.subGroupInUse = {\n        index: index,\n        objectName: this.rawMesh.objectName,\n        groupName: this.rawMesh.groupName,\n        materialName: this.rawMesh.activeMtlName,\n        smoothingGroup: this.rawMesh.smoothingGroup.normalized,\n        vertices: [],\n        indexMappingsCount: 0,\n        indexMappings: [],\n        indices: [],\n        colors: [],\n        uvs: [],\n        normals: []\n      };\n      this.rawMesh.subGroups[index] = this.rawMesh.subGroupInUse;\n    }\n  },\n  _buildFace: function (faceIndexV, faceIndexU, faceIndexN) {\n    let subGroupInUse = this.rawMesh.subGroupInUse;\n    let scope = this;\n\n    let updateSubGroupInUse = function () {\n      let faceIndexVi = parseInt(faceIndexV);\n      let indexPointerV = 3 * (faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3);\n      let indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n      let vertices = subGroupInUse.vertices;\n      vertices.push(scope.vertices[indexPointerV++]);\n      vertices.push(scope.vertices[indexPointerV++]);\n      vertices.push(scope.vertices[indexPointerV]);\n\n      if (indexPointerC !== null) {\n        let colors = subGroupInUse.colors;\n        colors.push(scope.colors[indexPointerC++]);\n        colors.push(scope.colors[indexPointerC++]);\n        colors.push(scope.colors[indexPointerC]);\n      }\n\n      if (faceIndexU) {\n        let faceIndexUi = parseInt(faceIndexU);\n        let indexPointerU = 2 * (faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2);\n        let uvs = subGroupInUse.uvs;\n        uvs.push(scope.uvs[indexPointerU++]);\n        uvs.push(scope.uvs[indexPointerU]);\n      }\n\n      if (faceIndexN && !scope.disregardNormals) {\n        let faceIndexNi = parseInt(faceIndexN);\n        let indexPointerN = 3 * (faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3);\n        let normals = subGroupInUse.normals;\n        normals.push(scope.normals[indexPointerN++]);\n        normals.push(scope.normals[indexPointerN++]);\n        normals.push(scope.normals[indexPointerN]);\n      }\n    };\n\n    if (this.useIndices) {\n      if (this.disregardNormals) faceIndexN = undefined;\n      let mappingName = faceIndexV + (faceIndexU ? '_' + faceIndexU : '_n') + (faceIndexN ? '_' + faceIndexN : '_n');\n      let indicesPointer = subGroupInUse.indexMappings[mappingName];\n\n      if (indicesPointer === undefined || indicesPointer === null) {\n        indicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n        updateSubGroupInUse();\n        subGroupInUse.indexMappings[mappingName] = indicesPointer;\n        subGroupInUse.indexMappingsCount++;\n      } else {\n        this.rawMesh.counts.doubleIndicesCount++;\n      }\n\n      subGroupInUse.indices.push(indicesPointer);\n    } else {\n      updateSubGroupInUse();\n    }\n\n    this.rawMesh.counts.faceCount++;\n  },\n  _createRawMeshReport: function (inputObjectCount) {\n    return 'Input Object number: ' + inputObjectCount + '\\n\\tObject name: ' + this.rawMesh.objectName + '\\n\\tGroup name: ' + this.rawMesh.groupName + '\\n\\tMtllib name: ' + this.rawMesh.mtllibName + '\\n\\tVertex count: ' + this.vertices.length / 3 + '\\n\\tNormal count: ' + this.normals.length / 3 + '\\n\\tUV count: ' + this.uvs.length / 2 + '\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount + '\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount + '\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n  },\n\n  /**\n   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n   */\n  _finalizeRawMesh: function () {\n    let meshOutputGroupTemp = [];\n    let meshOutputGroup;\n    let absoluteVertexCount = 0;\n    let absoluteIndexMappingsCount = 0;\n    let absoluteIndexCount = 0;\n    let absoluteColorCount = 0;\n    let absoluteNormalCount = 0;\n    let absoluteUvCount = 0;\n    let indices;\n\n    for (let name in this.rawMesh.subGroups) {\n      meshOutputGroup = this.rawMesh.subGroups[name];\n\n      if (meshOutputGroup.vertices.length > 0) {\n        indices = meshOutputGroup.indices;\n\n        if (indices.length > 0 && absoluteIndexMappingsCount > 0) {\n          for (let i = 0; i < indices.length; i++) {\n            indices[i] = indices[i] + absoluteIndexMappingsCount;\n          }\n        }\n\n        meshOutputGroupTemp.push(meshOutputGroup);\n        absoluteVertexCount += meshOutputGroup.vertices.length;\n        absoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n        absoluteIndexCount += meshOutputGroup.indices.length;\n        absoluteColorCount += meshOutputGroup.colors.length;\n        absoluteUvCount += meshOutputGroup.uvs.length;\n        absoluteNormalCount += meshOutputGroup.normals.length;\n      }\n    } // do not continue if no result\n\n\n    let result = null;\n\n    if (meshOutputGroupTemp.length > 0) {\n      result = {\n        name: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n        subGroups: meshOutputGroupTemp,\n        absoluteVertexCount: absoluteVertexCount,\n        absoluteIndexCount: absoluteIndexCount,\n        absoluteColorCount: absoluteColorCount,\n        absoluteNormalCount: absoluteNormalCount,\n        absoluteUvCount: absoluteUvCount,\n        faceCount: this.rawMesh.counts.faceCount,\n        doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n      };\n    }\n\n    return result;\n  },\n  _processCompletedMesh: function () {\n    let result = this._finalizeRawMesh();\n\n    let haveMesh = result !== null;\n\n    if (haveMesh) {\n      if (this.colors.length > 0 && this.colors.length !== this.vertices.length) {\n        this.callbacks.onError('Vertex Colors were detected, but vertex count and color count do not match!');\n      }\n\n      if (this.logging.enabled && this.logging.debug) console.debug(this._createRawMeshReport(this.inputObjectCount));\n      this.inputObjectCount++;\n\n      this._buildMesh(result);\n\n      let progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\n      this._onProgress('Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' + '] Total progress: ' + (progressBytesPercent * 100).toFixed(2) + '%');\n\n      this._resetRawMesh();\n    }\n\n    return haveMesh;\n  },\n\n  /**\n   * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.\n   * It is ensured that SubGroups only contain objects with vertices (no need to check).\n   *\n   * @param result\n   */\n  _buildMesh: function (result) {\n    let meshOutputGroups = result.subGroups;\n    let vertexFA = new Float32Array(result.absoluteVertexCount);\n    this.globalCounts.vertices += result.absoluteVertexCount / 3;\n    this.globalCounts.faces += result.faceCount;\n    this.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n    let indexUA = result.absoluteIndexCount > 0 ? new Uint32Array(result.absoluteIndexCount) : null;\n    let colorFA = result.absoluteColorCount > 0 ? new Float32Array(result.absoluteColorCount) : null;\n    let normalFA = result.absoluteNormalCount > 0 ? new Float32Array(result.absoluteNormalCount) : null;\n    let uvFA = result.absoluteUvCount > 0 ? new Float32Array(result.absoluteUvCount) : null;\n    let haveVertexColors = colorFA !== null;\n    let meshOutputGroup;\n    let materialNames = [];\n    let createMultiMaterial = meshOutputGroups.length > 1;\n    let materialIndex = 0;\n    let materialIndexMapping = [];\n    let selectedMaterialIndex;\n    let materialGroup;\n    let materialGroups = [];\n    let vertexFAOffset = 0;\n    let indexUAOffset = 0;\n    let colorFAOffset = 0;\n    let normalFAOffset = 0;\n    let uvFAOffset = 0;\n    let materialGroupOffset = 0;\n    let materialGroupLength = 0;\n    let materialOrg, material, materialName, materialNameOrg; // only one specific face type\n\n    for (let oodIndex in meshOutputGroups) {\n      if (!meshOutputGroups.hasOwnProperty(oodIndex)) continue;\n      meshOutputGroup = meshOutputGroups[oodIndex];\n      materialNameOrg = meshOutputGroup.materialName;\n\n      if (this.rawMesh.faceType < 4) {\n        materialName = materialNameOrg + (haveVertexColors ? '_vertexColor' : '') + (meshOutputGroup.smoothingGroup === 0 ? '_flat' : '');\n      } else {\n        materialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n      }\n\n      materialOrg = this.materials[materialNameOrg];\n      material = this.materials[materialName]; // both original and derived names do not lead to an existing material => need to use a default material\n\n      if ((materialOrg === undefined || materialOrg === null) && (material === undefined || material === null)) {\n        materialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n        material = this.materials[materialName];\n\n        if (this.logging.enabled) {\n          console.info('object_group \"' + meshOutputGroup.objectName + '_' + meshOutputGroup.groupName + '\" was defined with unresolvable material \"' + materialNameOrg + '\"! Assigning \"' + materialName + '\".');\n        }\n      }\n\n      if (material === undefined || material === null) {\n        let materialCloneInstructions = {\n          materialNameOrg: materialNameOrg,\n          materialName: materialName,\n          materialProperties: {\n            vertexColors: haveVertexColors ? 2 : 0,\n            flatShading: meshOutputGroup.smoothingGroup === 0\n          }\n        };\n        let payload = {\n          cmd: 'assetAvailable',\n          type: 'material',\n          materials: {\n            materialCloneInstructions: materialCloneInstructions\n          }\n        };\n        this.callbacks.onAssetAvailable(payload); // only set materials if they don't exist, yet\n\n        let matCheck = this.materials[materialName];\n\n        if (matCheck === undefined || matCheck === null) {\n          this.materials[materialName] = materialCloneInstructions;\n        }\n      }\n\n      if (createMultiMaterial) {\n        // re-use material if already used before. Reduces materials array size and eliminates duplicates\n        selectedMaterialIndex = materialIndexMapping[materialName];\n\n        if (!selectedMaterialIndex) {\n          selectedMaterialIndex = materialIndex;\n          materialIndexMapping[materialName] = materialIndex;\n          materialNames.push(materialName);\n          materialIndex++;\n        }\n\n        materialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n        materialGroup = {\n          start: materialGroupOffset,\n          count: materialGroupLength,\n          index: selectedMaterialIndex\n        };\n        materialGroups.push(materialGroup);\n        materialGroupOffset += materialGroupLength;\n      } else {\n        materialNames.push(materialName);\n      }\n\n      vertexFA.set(meshOutputGroup.vertices, vertexFAOffset);\n      vertexFAOffset += meshOutputGroup.vertices.length;\n\n      if (indexUA) {\n        indexUA.set(meshOutputGroup.indices, indexUAOffset);\n        indexUAOffset += meshOutputGroup.indices.length;\n      }\n\n      if (colorFA) {\n        colorFA.set(meshOutputGroup.colors, colorFAOffset);\n        colorFAOffset += meshOutputGroup.colors.length;\n      }\n\n      if (normalFA) {\n        normalFA.set(meshOutputGroup.normals, normalFAOffset);\n        normalFAOffset += meshOutputGroup.normals.length;\n      }\n\n      if (uvFA) {\n        uvFA.set(meshOutputGroup.uvs, uvFAOffset);\n        uvFAOffset += meshOutputGroup.uvs.length;\n      }\n\n      if (this.logging.enabled && this.logging.debug) {\n        let materialIndexLine = '';\n\n        if (selectedMaterialIndex) {\n          materialIndexLine = '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\n        }\n\n        let createdReport = '\\tOutput Object no.: ' + this.outputObjectCount + '\\n\\t\\tgroupName: ' + meshOutputGroup.groupName + '\\n\\t\\tIndex: ' + meshOutputGroup.index + '\\n\\t\\tfaceType: ' + this.rawMesh.faceType + '\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName + '\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup + materialIndexLine + '\\n\\t\\tobjectName: ' + meshOutputGroup.objectName + '\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 + '\\n\\t\\t#indices: ' + meshOutputGroup.indices.length + '\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 + '\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 + '\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n        console.debug(createdReport);\n      }\n    }\n\n    this.outputObjectCount++;\n    this.callbacks.onAssetAvailable({\n      cmd: 'assetAvailable',\n      type: 'mesh',\n      progress: {\n        numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n      },\n      params: {\n        meshName: result.name\n      },\n      materials: {\n        multiMaterial: createMultiMaterial,\n        materialNames: materialNames,\n        materialGroups: materialGroups\n      },\n      buffers: {\n        vertices: vertexFA,\n        indices: indexUA,\n        colors: colorFA,\n        normals: normalFA,\n        uvs: uvFA\n      },\n      // 0: mesh, 1: line, 2: point\n      geometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1\n    }, [vertexFA.buffer], indexUA !== null ? [indexUA.buffer] : null, colorFA !== null ? [colorFA.buffer] : null, normalFA !== null ? [normalFA.buffer] : null, uvFA !== null ? [uvFA.buffer] : null);\n  },\n  _finalizeParsing: function () {\n    if (this.logging.enabled) console.info('Global output object count: ' + this.outputObjectCount);\n\n    if (this._processCompletedMesh() && this.logging.enabled) {\n      let parserFinalReport = 'Overall counts: ' + '\\n\\tVertices: ' + this.globalCounts.vertices + '\\n\\tFaces: ' + this.globalCounts.faces + '\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n      console.info(parserFinalReport);\n    }\n  }\n};\nexport { OBJLoader2Parser };","map":{"version":3,"sources":["C:/Users/Admin/Desktop/Docs/Web/cg/cg_panner/node_modules/three/examples/jsm/loaders/obj2/OBJLoader2Parser.js"],"names":["OBJLoader2Parser","logging","enabled","debug","scope","callbacks","onProgress","text","_onProgress","onAssetAvailable","payload","_onAssetAvailable","onError","errorMessage","_onError","onLoad","object3d","message","_onLoad","contentRef","legacyMode","materials","materialPerSmoothingGroup","useOAsMesh","useIndices","disregardNormals","vertices","colors","normals","uvs","rawMesh","objectName","groupName","activeMtlName","mtllibName","faceType","subGroups","subGroupInUse","smoothingGroup","splitMaterials","normalized","real","counts","doubleIndicesCount","faceCount","mtlCount","smoothingGroupCount","inputObjectCount","outputObjectCount","globalCounts","faces","lineByte","currentByte","totalBytes","prototype","constructor","_resetRawMesh","_pushSmoothingGroup","setMaterialPerSmoothingGroup","setUseOAsMesh","setUseIndices","setDisregardNormals","setMaterials","Object","assign","setCallbackOnAssetAvailable","undefined","Function","setCallbackOnProgress","setCallbackOnError","setCallbackOnLoad","console","log","error","setLogging","_configure","matKeys","keys","matNames","length","join","printedConfig","name","info","execute","arrayBuffer","time","arrayBufferView","Uint8Array","byteLength","buffer","Array","bufferPointer","slashesCount","word","code","_processLine","String","fromCharCode","_finalizeParsing","timeEnd","executeLegacy","char","reconstructString","content","start","stop","line","i","trim","bufferLength","lineDesignation","push","parseFloat","_checkFaceType","_buildFace","_processCompletedMesh","mtlName","_checkSubGroup","smoothingGroupInt","parseInt","isNaN","smoothCheck","index","materialName","indexMappingsCount","indexMappings","indices","faceIndexV","faceIndexU","faceIndexN","updateSubGroupInUse","faceIndexVi","indexPointerV","indexPointerC","faceIndexUi","indexPointerU","faceIndexNi","indexPointerN","mappingName","indicesPointer","_createRawMeshReport","_finalizeRawMesh","meshOutputGroupTemp","meshOutputGroup","absoluteVertexCount","absoluteIndexMappingsCount","absoluteIndexCount","absoluteColorCount","absoluteNormalCount","absoluteUvCount","result","haveMesh","_buildMesh","progressBytesPercent","toFixed","meshOutputGroups","vertexFA","Float32Array","indexUA","Uint32Array","colorFA","normalFA","uvFA","haveVertexColors","materialNames","createMultiMaterial","materialIndex","materialIndexMapping","selectedMaterialIndex","materialGroup","materialGroups","vertexFAOffset","indexUAOffset","colorFAOffset","normalFAOffset","uvFAOffset","materialGroupOffset","materialGroupLength","materialOrg","material","materialNameOrg","oodIndex","hasOwnProperty","materialCloneInstructions","materialProperties","vertexColors","flatShading","cmd","type","matCheck","count","set","materialIndexLine","createdReport","progress","numericalValue","params","meshName","multiMaterial","buffers","geometryType","parserFinalReport"],"mappings":"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","sourcesContent":["/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n/**\n * Parse OBJ data either from ArrayBuffer or string\n */\nconst OBJLoader2Parser = function () {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tlet scope = this;\n\tthis.callbacks = {\n\t\tonProgress: function ( text ) {\n\n\t\t\tscope._onProgress( text );\n\n\t\t},\n\t\tonAssetAvailable: function ( payload ) {\n\n\t\t\tscope._onAssetAvailable( payload );\n\n\t\t},\n\t\tonError: function ( errorMessage ) {\n\n\t\t\tscope._onError( errorMessage );\n\n\t\t},\n\t\tonLoad: function ( object3d, message ) {\n\n\t\t\tscope._onLoad( object3d, message );\n\n\t\t},\n\t};\n\tthis.contentRef = null;\n\tthis.legacyMode = false;\n\n\tthis.materials = {};\n\tthis.materialPerSmoothingGroup = false;\n\tthis.useOAsMesh = false;\n\tthis.useIndices = false;\n\tthis.disregardNormals = false;\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.normals = [];\n\tthis.uvs = [];\n\n\tthis.rawMesh = {\n\t\tobjectName: '',\n\t\tgroupName: '',\n\t\tactiveMtlName: '',\n\t\tmtllibName: '',\n\n\t\t// reset with new mesh\n\t\tfaceType: - 1,\n\t\tsubGroups: [],\n\t\tsubGroupInUse: null,\n\t\tsmoothingGroup: {\n\t\t\tsplitMaterials: false,\n\t\t\tnormalized: - 1,\n\t\t\treal: - 1\n\t\t},\n\t\tcounts: {\n\t\t\tdoubleIndicesCount: 0,\n\t\t\tfaceCount: 0,\n\t\t\tmtlCount: 0,\n\t\t\tsmoothingGroupCount: 0\n\t\t}\n\t};\n\n\tthis.inputObjectCount = 1;\n\tthis.outputObjectCount = 1;\n\tthis.globalCounts = {\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tdoubleIndicesCount: 0,\n\t\tlineByte: 0,\n\t\tcurrentByte: 0,\n\t\ttotalBytes: 0\n\t};\n\n};\n\nOBJLoader2Parser.prototype = {\n\n\tconstructor: OBJLoader2Parser,\n\n\t_resetRawMesh: function () {\n\n\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\n\t\tthis.rawMesh.subGroups = [];\n\t\tthis.rawMesh.subGroupInUse = null;\n\t\tthis.rawMesh.smoothingGroup.normalized = - 1;\n\t\tthis.rawMesh.smoothingGroup.real = - 1;\n\n\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\t\tthis._pushSmoothingGroup( 1 );\n\n\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\n\t\tthis.rawMesh.counts.faceCount = 0;\n\t\tthis.rawMesh.counts.mtlCount = 0;\n\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\n\n\t},\n\n\t/**\n\t * Tells whether a material shall be created per smoothing group.\n\t *\n\t * @param {boolean} materialPerSmoothingGroup=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n\t *\n\t * @param {boolean} useOAsMesh=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.useOAsMesh = useOAsMesh === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Instructs loaders to create indexed {@link BufferGeometry}.\n\t *\n\t * @param {boolean} useIndices=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.useIndices = useIndices === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Tells whether normals should be completely disregarded and regenerated.\n\t *\n\t * @param {boolean} disregardNormals=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.disregardNormals = disregardNormals === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Clears materials object and sets the new ones.\n\t *\n\t * @param {Object} materials Object with named materials\n\t */\n\tsetMaterials: function ( materials ) {\n\n \t\tthis.materials = Object.assign( {}, materials );\n\n\t},\n\n\t/**\n\t * Register a function that is called once an asset (mesh/material) becomes available.\n\t *\n\t * @param onAssetAvailable\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tif ( onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function ) {\n\n\t\t\tthis.callbacks.onAssetAvailable = onAssetAvailable;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is used to report overall processing progress.\n\t *\n\t * @param {Function} onProgress\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.\n\t *\n\t * @param {Function} onError\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tif ( onError !== null && onError !== undefined && onError instanceof Function ) {\n\n\t\t\tthis.callbacks.onError = onError;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called when parsing was completed.\n\t *\n\t * @param {Function} onLoad\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tif ( onLoad !== null && onLoad !== undefined && onLoad instanceof Function ) {\n\n\t\t\tthis.callbacks.onLoad = onLoad;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Announce parse progress feedback which is logged to the console.\n\t * @private\n\t *\n\t * @param {string} text Textual description of the event\n\t */\n\t_onProgress: function ( text ) {\n\n\t\tlet message = text ? text : '';\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Announce error feedback which is logged as error message.\n\t * @private\n\t *\n\t * @param {String} errorMessage The event containing the error\n\t */\n\t_onError: function ( errorMessage ) {\n\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.error( errorMessage );\n\n\t\t}\n\n\t},\n\n\t_onAssetAvailable: function ( payload ) {\n\n\t\tlet errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\n\t\tthis.callbacks.onError( errorMessage );\n\t\tthrow errorMessage;\n\n\t},\n\n\t_onLoad: function ( object3d, message ) {\n\n\t\tconsole.log( \"You reached parser default onLoad callback: \" + message );\n\n\t},\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t *\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\treturn this;\n\n\t},\n\n\t_configure: function () {\n\n\t\tthis._pushSmoothingGroup( 1 );\n\t\tif ( this.logging.enabled ) {\n\n\t\t\tlet matKeys = Object.keys( this.materials );\n\t\t\tlet matNames = ( matKeys.length > 0 ) ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join( '\\n\\t\\t- ' ) : '\\n\\tmaterialNames: None';\n\t\t\tlet printedConfig = 'OBJLoader.Parser configuration:'\n\t\t\t\t+ matNames\n\t\t\t\t+ '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup\n\t\t\t\t+ '\\n\\tuseOAsMesh: ' + this.useOAsMesh\n\t\t\t\t+ '\\n\\tuseIndices: ' + this.useIndices\n\t\t\t\t+ '\\n\\tdisregardNormals: ' + this.disregardNormals;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\n\t\t\tconsole.info( printedConfig );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Parse the provided arraybuffer\n\t *\n\t * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n\t */\n\texecute: function ( arrayBuffer ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.execute' );\n\t\tthis._configure();\n\n\t\tlet arrayBufferView = new Uint8Array( arrayBuffer );\n\t\tthis.contentRef = arrayBufferView;\n\t\tlet length = arrayBufferView.byteLength;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tlet buffer = new Array( 128 );\n\n\t\tlet bufferPointer = 0;\n\t\tlet slashesCount = 0;\n\t\tlet word = '';\n\t\tlet currentByte = 0;\n\t\tfor ( let code, currentByte = 0; currentByte < length; currentByte ++ ) {\n\n\t\t\tcode = arrayBufferView[ currentByte ];\n\t\t\tswitch ( code ) {\n\n\t\t\t\t// space\n\t\t\t\tcase 32:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\t\t\t\t// slash\n\t\t\t\tcase 47:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LF\n\t\t\t\tcase 10:\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\t\t\t\tword = '';\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// CR\n\t\t\t\tcase 13:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += String.fromCharCode( code );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.execute' );\n\n\t},\n\n\t/**\n\t * Parse the provided text\n\t *\n\t * @param {string} text OBJ data as string\n\t */\n\texecuteLegacy: function ( text ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.executeLegacy' );\n\t\tthis._configure();\n\t\tthis.legacyMode = true;\n\t\tthis.contentRef = text;\n\t\tlet length = text.length;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tlet buffer = new Array( 128 );\n\n\t\tlet bufferPointer = 0;\n\t\tlet slashesCount = 0;\n\t\tlet word = '';\n\t\tlet currentByte = 0;\n\t\tfor ( let char; currentByte < length; currentByte ++ ) {\n\n\t\t\tchar = text[ currentByte ];\n\t\t\tswitch ( char ) {\n\n\t\t\t\tcase ' ':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '/':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\n':\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount, word, currentByte );\n\t\t\t\t\tword = '';\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\r':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += char;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._processLine( buffer, bufferPointer, word, slashesCount );\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.executeLegacy' );\n\n\t},\n\n\t_processLine: function ( buffer, bufferPointer, slashesCount, word, currentByte ) {\n\n\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\tthis.globalCounts.currentByte = currentByte;\n\t\tif ( bufferPointer < 1 ) return;\n\n\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\n\t\tlet reconstructString = function ( content, legacyMode, start, stop ) {\n\n\t\t\tlet line = '';\n\t\t\tif ( stop > start ) {\n\n\t\t\t\tlet i;\n\t\t\t\tif ( legacyMode ) {\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += content[ i ];\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += String.fromCharCode( content[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tline = line.trim();\n\n\t\t\t}\n\n\t\t\treturn line;\n\n\t\t};\n\n\t\tlet bufferLength, length, i, lineDesignation;\n\t\tlineDesignation = buffer[ 0 ];\n\t\tswitch ( lineDesignation ) {\n\n\t\t\tcase 'v':\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tif ( bufferPointer > 4 ) {\n\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 4 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 5 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 6 ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'vt':\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'vn':\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\n\t\t\t\t// \"f vertex ...\"\n\t\t\t\tif ( slashesCount === 0 ) {\n\n\t\t\t\t\tthis._checkFaceType( 0 );\n\t\t\t\t\tfor ( i = 2, length = bufferLength; i < length; i ++ ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv ...\"\n\n\t\t\t\t} else if ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 1 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv/normal ...\"\n\n\t\t\t\t} else if ( bufferLength * 2 === slashesCount * 3 ) {\n\n\t\t\t\t\tthis._checkFaceType( 2 );\n\t\t\t\t\tfor ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex//normal ...\"\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( 3 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\tcase 'p':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\t\t\t\tif ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 4 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i += 2 ) this._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i ++ ) this._buildFace( buffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tthis._pushSmoothingGroup( buffer[ 1 ] );\n\t\t\t\tbreak;\n\n\t\t\tcase 'g':\n\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n\t\t\t\tthis._processCompletedMesh();\n\t\t\t\tthis.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'o':\n\t\t\t\t// 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n\t\t\t\tif ( this.useOAsMesh ) this._processCompletedMesh();\n\t\t\t\tthis.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'mtllib':\n\t\t\t\tthis.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'usemtl':\n\t\t\t\tlet mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tif ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {\n\n\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\n\t\t\t\t\tthis.rawMesh.counts.mtlCount ++;\n\t\t\t\t\tthis._checkSubGroup();\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\n\t},\n\n\t_pushSmoothingGroup: function ( smoothingGroup ) {\n\n\t\tlet smoothingGroupInt = parseInt( smoothingGroup );\n\t\tif ( isNaN( smoothingGroupInt ) ) {\n\n\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n\n\t\t}\n\n\t\tlet smoothCheck = this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;\n\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n\t\tif ( smoothCheck !== smoothingGroupInt ) {\n\n\t\t\tthis.rawMesh.counts.smoothingGroupCount ++;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Expanded faceTypes include all four face types, both line types and the point type\n\t * faceType = 0: \"f vertex ...\"\n\t * faceType = 1: \"f vertex/uv ...\"\n\t * faceType = 2: \"f vertex/uv/normal ...\"\n\t * faceType = 3: \"f vertex//normal ...\"\n\t * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n\t * faceType = 5: \"l vertex ...\"\n\t * faceType = 6: \"p vertex ...\"\n\t */\n\t_checkFaceType: function ( faceType ) {\n\n\t\tif ( this.rawMesh.faceType !== faceType ) {\n\n\t\t\tthis._processCompletedMesh();\n\t\t\tthis.rawMesh.faceType = faceType;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t_checkSubGroup: function () {\n\n\t\tlet index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];\n\n\t\tif ( this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null ) {\n\n\t\t\tthis.rawMesh.subGroupInUse = {\n\t\t\t\tindex: index,\n\t\t\t\tobjectName: this.rawMesh.objectName,\n\t\t\t\tgroupName: this.rawMesh.groupName,\n\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\n\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\n\t\t\t\tvertices: [],\n\t\t\t\tindexMappingsCount: 0,\n\t\t\t\tindexMappings: [],\n\t\t\t\tindices: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tnormals: []\n\t\t\t};\n\t\t\tthis.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;\n\n\t\t}\n\n\t},\n\n\t_buildFace: function ( faceIndexV, faceIndexU, faceIndexN ) {\n\n\t\tlet subGroupInUse = this.rawMesh.subGroupInUse;\n\t\tlet scope = this;\n\t\tlet updateSubGroupInUse = function () {\n\n\t\t\tlet faceIndexVi = parseInt( faceIndexV );\n\t\t\tlet indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );\n\t\t\tlet indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n\n\t\t\tlet vertices = subGroupInUse.vertices;\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ] );\n\n\t\t\tif ( indexPointerC !== null ) {\n\n\t\t\t\tlet colors = subGroupInUse.colors;\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ] );\n\n\t\t\t}\n\n\t\t\tif ( faceIndexU ) {\n\n\t\t\t\tlet faceIndexUi = parseInt( faceIndexU );\n\t\t\t\tlet indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );\n\t\t\t\tlet uvs = subGroupInUse.uvs;\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ++ ] );\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ] );\n\n\t\t\t}\n\n\t\t\tif ( faceIndexN && ! scope.disregardNormals ) {\n\n\t\t\t\tlet faceIndexNi = parseInt( faceIndexN );\n\t\t\t\tlet indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );\n\t\t\t\tlet normals = subGroupInUse.normals;\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( this.useIndices ) {\n\n\t\t\tif ( this.disregardNormals ) faceIndexN = undefined;\n\t\t\tlet mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );\n\t\t\tlet indicesPointer = subGroupInUse.indexMappings[ mappingName ];\n\t\t\tif ( indicesPointer === undefined || indicesPointer === null ) {\n\n\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n\t\t\t\tupdateSubGroupInUse();\n\t\t\t\tsubGroupInUse.indexMappings[ mappingName ] = indicesPointer;\n\t\t\t\tsubGroupInUse.indexMappingsCount ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.rawMesh.counts.doubleIndicesCount ++;\n\n\t\t\t}\n\n\t\t\tsubGroupInUse.indices.push( indicesPointer );\n\n\t\t} else {\n\n\t\t\tupdateSubGroupInUse();\n\n\t\t}\n\n\t\tthis.rawMesh.counts.faceCount ++;\n\n\t},\n\n\t_createRawMeshReport: function ( inputObjectCount ) {\n\n\t\treturn 'Input Object number: ' + inputObjectCount +\n\t\t\t'\\n\\tObject name: ' + this.rawMesh.objectName +\n\t\t\t'\\n\\tGroup name: ' + this.rawMesh.groupName +\n\t\t\t'\\n\\tMtllib name: ' + this.rawMesh.mtllibName +\n\t\t\t'\\n\\tVertex count: ' + this.vertices.length / 3 +\n\t\t\t'\\n\\tNormal count: ' + this.normals.length / 3 +\n\t\t\t'\\n\\tUV count: ' + this.uvs.length / 2 +\n\t\t\t'\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +\n\t\t\t'\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount +\n\t\t\t'\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n\n\t},\n\n\t/**\n\t * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n\t */\n\t_finalizeRawMesh: function () {\n\n\t\tlet meshOutputGroupTemp = [];\n\t\tlet meshOutputGroup;\n\t\tlet absoluteVertexCount = 0;\n\t\tlet absoluteIndexMappingsCount = 0;\n\t\tlet absoluteIndexCount = 0;\n\t\tlet absoluteColorCount = 0;\n\t\tlet absoluteNormalCount = 0;\n\t\tlet absoluteUvCount = 0;\n\t\tlet indices;\n\t\tfor ( let name in this.rawMesh.subGroups ) {\n\n\t\t\tmeshOutputGroup = this.rawMesh.subGroups[ name ];\n\t\t\tif ( meshOutputGroup.vertices.length > 0 ) {\n\n\t\t\t\tindices = meshOutputGroup.indices;\n\t\t\t\tif ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = indices[ i ] + absoluteIndexMappingsCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmeshOutputGroupTemp.push( meshOutputGroup );\n\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\n\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\n\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\n\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\n\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do not continue if no result\n\t\tlet result = null;\n\t\tif ( meshOutputGroupTemp.length > 0 ) {\n\n\t\t\tresult = {\n\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n\t\t\t\tsubGroups: meshOutputGroupTemp,\n\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\n\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\n\t\t\t\tabsoluteColorCount: absoluteColorCount,\n\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\n\t\t\t\tabsoluteUvCount: absoluteUvCount,\n\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\n\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t_processCompletedMesh: function () {\n\n\t\tlet result = this._finalizeRawMesh();\n\t\tlet haveMesh = result !== null;\n\t\tif ( haveMesh ) {\n\n\t\t\tif ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {\n\n\t\t\t\tthis.callbacks.onError( 'Vertex Colors were detected, but vertex count and color count do not match!' );\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) console.debug( this._createRawMeshReport( this.inputObjectCount ) );\n\t\t\tthis.inputObjectCount ++;\n\n\t\t\tthis._buildMesh( result );\n\t\t\tlet progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\t\t\tthis._onProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' +\n\t\t\t\t'] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%' );\n\t\t\tthis._resetRawMesh();\n\n\t\t}\n\n\t\treturn haveMesh;\n\n\t},\n\n\t/**\n\t * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.\n\t * It is ensured that SubGroups only contain objects with vertices (no need to check).\n\t *\n\t * @param result\n\t */\n\t_buildMesh: function ( result ) {\n\n\t\tlet meshOutputGroups = result.subGroups;\n\n\t\tlet vertexFA = new Float32Array( result.absoluteVertexCount );\n\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\n\t\tthis.globalCounts.faces += result.faceCount;\n\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n\t\tlet indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;\n\t\tlet colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;\n\t\tlet normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;\n\t\tlet uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;\n\t\tlet haveVertexColors = colorFA !== null;\n\n\t\tlet meshOutputGroup;\n\t\tlet materialNames = [];\n\n\t\tlet createMultiMaterial = ( meshOutputGroups.length > 1 );\n\t\tlet materialIndex = 0;\n\t\tlet materialIndexMapping = [];\n\t\tlet selectedMaterialIndex;\n\t\tlet materialGroup;\n\t\tlet materialGroups = [];\n\n\t\tlet vertexFAOffset = 0;\n\t\tlet indexUAOffset = 0;\n\t\tlet colorFAOffset = 0;\n\t\tlet normalFAOffset = 0;\n\t\tlet uvFAOffset = 0;\n\t\tlet materialGroupOffset = 0;\n\t\tlet materialGroupLength = 0;\n\n\t\tlet materialOrg, material, materialName, materialNameOrg;\n\t\t// only one specific face type\n\t\tfor ( let oodIndex in meshOutputGroups ) {\n\n\t\t\tif ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) continue;\n\t\t\tmeshOutputGroup = meshOutputGroups[ oodIndex ];\n\n\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\n\t\t\tif ( this.rawMesh.faceType < 4 ) {\n\n\t\t\t\tmaterialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );\n\n\n\t\t\t} else {\n\n\t\t\t\tmaterialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\n\t\t\t}\n\n\t\t\tmaterialOrg = this.materials[ materialNameOrg ];\n\t\t\tmaterial = this.materials[ materialName ];\n\n\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\n\t\t\tif ( ( materialOrg === undefined || materialOrg === null ) && ( material === undefined || material === null ) ) {\n\n\t\t\t\tmaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n\t\t\t\tmaterial = this.materials[ materialName ];\n\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\tconsole.info( 'object_group \"' + meshOutputGroup.objectName + '_' +\n\t\t\t\t\t\tmeshOutputGroup.groupName + '\" was defined with unresolvable material \"' +\n\t\t\t\t\t\tmaterialNameOrg + '\"! Assigning \"' + materialName + '\".' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material === undefined || material === null ) {\n\n\t\t\t\tlet materialCloneInstructions = {\n\t\t\t\t\tmaterialNameOrg: materialNameOrg,\n\t\t\t\t\tmaterialName: materialName,\n\t\t\t\t\tmaterialProperties: {\n\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\n\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet payload = {\n\t\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tmaterials: {\n\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.callbacks.onAssetAvailable( payload );\n\n\t\t\t\t// only set materials if they don't exist, yet\n\t\t\t\tlet matCheck = this.materials[ materialName ];\n\t\t\t\tif ( matCheck === undefined || matCheck === null ) {\n\n\t\t\t\t\tthis.materials[ materialName ] = materialCloneInstructions;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( createMultiMaterial ) {\n\n\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\n\t\t\t\tselectedMaterialIndex = materialIndexMapping[ materialName ];\n\t\t\t\tif ( ! selectedMaterialIndex ) {\n\n\t\t\t\t\tselectedMaterialIndex = materialIndex;\n\t\t\t\t\tmaterialIndexMapping[ materialName ] = materialIndex;\n\t\t\t\t\tmaterialNames.push( materialName );\n\t\t\t\t\tmaterialIndex ++;\n\n\t\t\t\t}\n\n\t\t\t\tmaterialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n\t\t\t\tmaterialGroup = {\n\t\t\t\t\tstart: materialGroupOffset,\n\t\t\t\t\tcount: materialGroupLength,\n\t\t\t\t\tindex: selectedMaterialIndex\n\t\t\t\t};\n\t\t\t\tmaterialGroups.push( materialGroup );\n\t\t\t\tmaterialGroupOffset += materialGroupLength;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialNames.push( materialName );\n\n\t\t\t}\n\n\t\t\tvertexFA.set( meshOutputGroup.vertices, vertexFAOffset );\n\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\n\n\t\t\tif ( indexUA ) {\n\n\t\t\t\tindexUA.set( meshOutputGroup.indices, indexUAOffset );\n\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\n\n\t\t\t}\n\n\t\t\tif ( colorFA ) {\n\n\t\t\t\tcolorFA.set( meshOutputGroup.colors, colorFAOffset );\n\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\n\n\t\t\t}\n\n\t\t\tif ( normalFA ) {\n\n\t\t\t\tnormalFA.set( meshOutputGroup.normals, normalFAOffset );\n\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t\tif ( uvFA ) {\n\n\t\t\t\tuvFA.set( meshOutputGroup.uvs, uvFAOffset );\n\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\t\tlet materialIndexLine = '';\n\t\t\t\tif ( selectedMaterialIndex ) {\n\n\t\t\t\t\tmaterialIndexLine = '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\n\n\t\t\t\t}\n\n\t\t\t\tlet createdReport = '\\tOutput Object no.: ' + this.outputObjectCount +\n\t\t\t\t\t'\\n\\t\\tgroupName: ' + meshOutputGroup.groupName +\n\t\t\t\t\t'\\n\\t\\tIndex: ' + meshOutputGroup.index +\n\t\t\t\t\t'\\n\\t\\tfaceType: ' + this.rawMesh.faceType +\n\t\t\t\t\t'\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName +\n\t\t\t\t\t'\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +\n\t\t\t\t\tmaterialIndexLine +\n\t\t\t\t\t'\\n\\t\\tobjectName: ' + meshOutputGroup.objectName +\n\t\t\t\t\t'\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#indices: ' + meshOutputGroup.indices.length +\n\t\t\t\t\t'\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 +\n\t\t\t\t\t'\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n\t\t\t\tconsole.debug( createdReport );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.outputObjectCount ++;\n\t\tthis.callbacks.onAssetAvailable(\n\t\t\t{\n\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\ttype: 'mesh',\n\t\t\t\tprogress: {\n\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\tmeshName: result.name\n\t\t\t\t},\n\t\t\t\tmaterials: {\n\t\t\t\t\tmultiMaterial: createMultiMaterial,\n\t\t\t\t\tmaterialNames: materialNames,\n\t\t\t\t\tmaterialGroups: materialGroups\n\t\t\t\t},\n\t\t\t\tbuffers: {\n\t\t\t\t\tvertices: vertexFA,\n\t\t\t\t\tindices: indexUA,\n\t\t\t\t\tcolors: colorFA,\n\t\t\t\t\tnormals: normalFA,\n\t\t\t\t\tuvs: uvFA\n\t\t\t\t},\n\t\t\t\t// 0: mesh, 1: line, 2: point\n\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1\n\t\t\t},\n\t\t\t[ vertexFA.buffer ],\n\t\t\tindexUA !== null ? [ indexUA.buffer ] : null,\n\t\t\tcolorFA !== null ? [ colorFA.buffer ] : null,\n\t\t\tnormalFA !== null ? [ normalFA.buffer ] : null,\n\t\t\tuvFA !== null ? [ uvFA.buffer ] : null\n\t\t);\n\n\t},\n\n\t_finalizeParsing: function () {\n\n\t\tif ( this.logging.enabled ) console.info( 'Global output object count: ' + this.outputObjectCount );\n\t\tif ( this._processCompletedMesh() && this.logging.enabled ) {\n\n\t\t\tlet parserFinalReport = 'Overall counts: ' +\n\t\t\t\t'\\n\\tVertices: ' + this.globalCounts.vertices +\n\t\t\t\t'\\n\\tFaces: ' + this.globalCounts.faces +\n\t\t\t\t'\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n\t\t\tconsole.info( parserFinalReport );\n\n\t\t}\n\n\t}\n};\n\nexport { OBJLoader2Parser };\n"]},"metadata":{},"sourceType":"module"}